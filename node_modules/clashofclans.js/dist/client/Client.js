"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const Constants_1 = require("../util/Constants");
const HTTPError_1 = require("../rest/HTTPError");
const RESTManager_1 = require("../rest/RESTManager");
const EventManager_1 = require("./EventManager");
const events_1 = require("events");
const Util_1 = require("../util/Util");
const struct_1 = require("../struct");
/**
 * Represents Clash of Clans API Client.
 * ```js
 * const { Client } = require('clashofclans.js');
 * const client = new Client({ keys: ['***'] });
 * ```
 */
class Client extends events_1.EventEmitter {
    constructor(options) {
        super();
        this.rest = new RESTManager_1.RESTManager({ ...options, rejectIfNotValid: true });
        this.events = new EventManager_1.EventManager(this);
    }
    /** Contains various general-purpose utility methods. */
    get util() {
        return Util_1.Util;
    }
    /** Whether the API is in maintenance break. */
    get inMaintenance() {
        // @ts-expect-error
        return this.events._inMaintenance;
    }
    /**
     * Initialize the client to create keys.
     * @example
     * ```
     * const client = new Client();
     * client.login({ email: 'developer@email.com', password: '***' });
     * ```
     */
    login(options) {
        return this.rest.handler.init(options);
    }
    /** Set Clash of Clans API keys. */
    setKeys(keys) {
        this.rest.handler.setKeys(keys);
        return this;
    }
    /** Search clans by name and/or filtering parameters or get clans by their tags (fetches in parallel). */
    async getClans(query, options) {
        if (Array.isArray(query)) {
            return (await Promise.allSettled(query.map((tag) => this.getClan(tag, options))))
                .filter((res) => res.status === 'fulfilled')
                .map((res) => res.value);
        }
        const { data } = await this.rest.getClans(query, options);
        // @ts-expect-error
        return data.items.map((clan) => new struct_1.Clan(this, clan));
    }
    /** Get info about a clan. */
    async getClan(clanTag, options) {
        const { data } = await this.rest.getClan(clanTag, options);
        return new struct_1.Clan(this, data);
    }
    /** Get list of clan members. */
    async getClanMembers(clanTag, options) {
        const { data } = await this.rest.getClanMembers(clanTag, options);
        return data.items.map((entry) => new struct_1.ClanMember(this, entry));
    }
    /** Get clan war log. */
    async getClanWarLog(clanTag, options) {
        const { data } = await this.rest.getClanWarLog(clanTag, options);
        return data.items.map((entry) => new struct_1.ClanWarLog(this, entry));
    }
    /** Get info about currently running war (normal or friendly) in the clan. */
    async getClanWar(clanTag, options) {
        const { data, maxAge, path, status } = await this.rest.getCurrentWar(clanTag, options);
        if (data.state === 'notInWar') {
            throw new HTTPError_1.HTTPError(HTTPError_1.NotInWarError, status, path, maxAge);
        }
        return new struct_1.ClanWar(this, data, { clanTag, maxAge });
    }
    /**
     * Get info about currently running war in the clan.
     * @example
     * ```ts
     * await client.getCurrentWar('#8QU8J9LP');
     * ```
     * @example
     * ```ts
     * await client.getCurrentWar({ clanTag: '#8QU8J9LP', round: 'PREVIOUS_ROUND' });
     * ```
     */
    async getCurrentWar(clanTag, options) {
        const args = typeof clanTag === 'string' ? { clanTag } : { clanTag: clanTag.clanTag, round: clanTag.round };
        try {
            return await this.getClanWar(args.clanTag, options);
        }
        catch (e) {
            if (e instanceof HTTPError_1.HTTPError && [200, 403].includes(e.status)) {
                return this.getLeagueWar({ clanTag: args.clanTag, round: args.round }, options);
            }
            throw e;
        }
    }
    /**
     * Get info about currently running CWL round.
     * @example
     * ```ts
     * await client.getLeagueWar('#8QU8J9LP');
     * ```
     * @example
     * ```ts
     * await client.getLeagueWar({ clanTag: '#8QU8J9LP', round: 'PREVIOUS_ROUND' });
     * ```
     */
    async getLeagueWar(clanTag, options) {
        const args = typeof clanTag === 'string' ? { clanTag } : { clanTag: clanTag.clanTag, round: clanTag.round };
        const state = (args.round && Constants_1.CWL_ROUNDS[args.round]) ?? 'inWar'; // eslint-disable-line
        const data = await this.getClanWarLeagueGroup(args.clanTag, options);
        const rounds = data.rounds.filter((round) => !round.warTags.includes('#0'));
        if (!rounds.length)
            return null;
        const num = state === 'preparation' ? -1 : state === 'warEnded' ? -3 : -2;
        const warTags = rounds
            .slice(num)
            .map((round) => round.warTags)
            .flat()
            .reverse();
        const wars = await this.util.allSettled(warTags.map((warTag) => this.getClanWarLeagueRound({ warTag, clanTag: args.clanTag }, { ...options, ignoreRateLimit: true })));
        if (args.round && args.round in Constants_1.CWL_ROUNDS) {
            return wars.find((war) => war.clan.tag === args.clanTag && war.state === state) ?? null;
        }
        return (wars.find((war) => war.clan.tag === args.clanTag && war.state === state) ??
            wars.find((war) => war.clan.tag === args.clanTag) ??
            null);
    }
    /** Returns active wars (last 2) of the CWL group. */
    async getLeagueWars(clanTag, options) {
        const data = await this.getClanWarLeagueGroup(clanTag, options);
        return data.getCurrentWars(clanTag, options);
    }
    /** Returns active wars (last 2 for CWL) of the clan. */
    async getWars(clanTag, options) {
        const date = new Date().getUTCDate();
        if (!(date >= 1 && date <= 10)) {
            return [await this.getClanWar(clanTag, options)];
        }
        try {
            return this.getLeagueWars(clanTag, options);
        }
        catch (e) {
            if (e instanceof HTTPError_1.HTTPError && [404].includes(e.status)) {
                return [await this.getClanWar(clanTag, options)];
            }
            throw e;
        }
    }
    /** Get info about clan war league. */
    async getClanWarLeagueGroup(clanTag, options) {
        const { data, status, path, maxAge } = await this.rest.getClanWarLeagueGroup(clanTag, options);
        if (data.state === 'notInWar') {
            throw new HTTPError_1.HTTPError(HTTPError_1.NotInWarError, status, path, maxAge);
        }
        return new struct_1.ClanWarLeagueGroup(this, data);
    }
    /** Get info about a CWL round by WarTag. */
    async getClanWarLeagueRound(warTag, options) {
        const args = typeof warTag === 'string' ? { warTag } : { warTag: warTag.warTag, clanTag: warTag.clanTag };
        const { data, maxAge, status, path } = await this.rest.getClanWarLeagueRound(args.warTag, options);
        if (data.state === 'notInWar') {
            throw new HTTPError_1.HTTPError(HTTPError_1.NotInWarError, status, path, maxAge);
        }
        return new struct_1.ClanWar(this, data, { warTag: args.warTag, clanTag: args.clanTag, maxAge });
    }
    /** Get info about a player by tag. */
    async getPlayer(playerTag, options) {
        const { data } = await this.rest.getPlayer(playerTag, options);
        return new struct_1.Player(this, data);
    }
    /** Get info about some players by their tags (fetches in parallel). */
    async getPlayers(playerTags, options) {
        return (await Promise.allSettled(playerTags.map((tag) => this.getPlayer(tag, options))))
            .filter((res) => res.status === 'fulfilled')
            .map((res) => res.value);
    }
    /** Verify Player API token that can be found from the Game settings. */
    async verifyPlayerToken(playerTag, token, options) {
        const { data } = await this.rest.verifyPlayerToken(playerTag, token, options);
        return data.status === 'ok';
    }
    /** Get list of Leagues. */
    async getLeagues(options) {
        const { data } = await this.rest.getLeagues(options);
        return data.items.map((entry) => new struct_1.League(entry));
    }
    /** Get Legend League season Ids. */
    async getLeagueSeasons(options) {
        const { data } = await this.rest.getLeagueSeasons(Constants_1.LEGEND_LEAGUE_ID, options);
        return data.items.map((league) => league.id);
    }
    /** Get Legend League season rankings by season Id. */
    async getSeasonRankings(seasonId, options) {
        const { data } = await this.rest.getSeasonRankings(Constants_1.LEGEND_LEAGUE_ID, seasonId, options);
        return data.items.map((entry) => new struct_1.SeasonRankedPlayer(this, entry));
    }
    /** Get list of Clan War Leagues. */
    async getWarLeagues(options) {
        const { data } = await this.rest.getWarLeagues(options);
        return data.items.map((entry) => new struct_1.WarLeague(entry));
    }
    /** Get list of Locations. */
    async getLocations(options) {
        const { data } = await this.rest.getLocations(options);
        return data.items.map((entry) => new struct_1.Location(entry));
    }
    /**
     * Get clan rankings for a specific location.
     *
     * For global ranking, use `global` as `locationId`.
     */
    async getClanRanks(locationId, options) {
        const { data } = await this.rest.getClanRanks(locationId, options);
        return data.items.map((entry) => new struct_1.RankedClan(entry));
    }
    /**
     * Get player rankings for a specific location.
     *
     * For global ranking, use `global` as `locationId`.
     */
    async getPlayerRanks(locationId, options) {
        const { data } = await this.rest.getPlayerRanks(locationId, options);
        return data.items.map((entry) => new struct_1.RankedPlayer(this, entry));
    }
    /**
     * Get clan versus rankings for a specific location.
     *
     * For global ranking, use `global` as `locationId`.
     */
    async getVersusClanRanks(locationId, options) {
        const { data } = await this.rest.getVersusClanRanks(locationId, options);
        return data.items.map((entry) => new struct_1.RankedClan(entry));
    }
    /**
     * Get player versus rankings for a specific location.
     *
     * For global ranking, use `global` as `locationId`.
     */
    async getVersusPlayerRanks(locationId, options) {
        const { data } = await this.rest.getVersusPlayerRanks(locationId, options);
        return data.items.map((entry) => new struct_1.RankedPlayer(this, entry));
    }
    /** Get list of clan labels. */
    async getClanLabels(options) {
        const { data } = await this.rest.getClanLabels(options);
        return data.items.map((entry) => new struct_1.Label(entry));
    }
    /** Get list of player labels. */
    async getPlayerLabels(options) {
        const { data } = await this.rest.getPlayerLabels(options);
        return data.items.map((entry) => new struct_1.Label(entry));
    }
    /** Get info about gold pass season. */
    async getGoldPassSeason(options) {
        const { data } = await this.rest.getGoldPassSeason(options);
        return new struct_1.GoldPassSeason(data);
    }
}
exports.Client = Client;
